---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x05:
DLLs and  Linking 


---
<!-- slide template="[[Title Slide]]" -->
 ## Review: PE File Format
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format Basic Definitions and Concepts 

:::

<!-- element style="font-size: 24px"-->
- Portable Executable (PE) is an executable file format used by Windows NT
- It contains information about code to 
execute
, and how it should be executed
- In this discussion, we will use an open source tool PE-Bear to look at the 
structure of a PE file.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format 

:::

<!-- element style="font-size: 24px"-->
- PE file format is used for both userland and kernel mode executables
	- Userland: file.exe, file.dll, file.obj 
	- Kernel mode: driver.sys, ntoskrnl.exe 
- PE 
is  based on the Common Object File Format (COFF).
- PE format is not architecture specific (hence “portable”)
	- Note this means the format can be used across multiple different architectures. The  target architecture is still specified inside of the PE though
- Data is grouped together in blocks called 
sections
, identified by 
headers


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Calc.exe
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x07_slide_12_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DOS Header
:::

::: left
<!-- element style="font-size: 24px"-->
- The DOS header contains the magic bytes MZ that identify it as a PE
- The final entry (offset 0x3c referenced as ->e_lfanew) is the offset the of NT Headers

:::

::: right
![[0x07_slide_13_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### NT Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Signatures
- File Header
- Optional Header


:::

::: right
![[0x07_slide_14_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Signature
:::

::: left
<!-- element style="font-size: 24px"-->
- Usually 4 bytes containing 
- “PE\0\0”
- For our purposes, it is only used to verify the file format. 

:::

::: right
![[0x07_slide_15_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### File Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Following the Signature, we have the File Headers. This gives us
- The number of sections (NumberOfSections)
- Whether or not we have a DLL/EXE (Characteristics)
- The Compilation timestamp 
- A pointer to a symbol table if one exists 


:::

::: right
![[0x07_slide_16_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- I don’t know why it is listed as optional. I don’t think a PE can run without this section (but I could be wrong?)
- The optional headers contains most of  the data required to load PE
- Specifically, values found here are used to build the 
Import Address Table
, and perform 
Base Relocations


:::

::: right
![[0x07_slide_17_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 1)
:::

::: left
<!-- element style="font-size: 24px"-->
- Magic: Architecture of image
- Entry Point: Relative virtual address (RVA) from the Base Address
- Image Base: (prefered) Base address: Where in memory the PE “prefers” to be loaded. If the location is unavailable, the Image needs to be relocated 

:::

::: right
![[0x07_slide_18_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 2)
:::

::: left
<!-- element style="font-size: 24px"-->
- SizeOfImage: the virtual size of the image 
- SizeOfHeaders: the size of the headers
- DLLCharacteristics: flags including knowledge of hardening features such as ASLR/ CFG...etc. Not super important for us other than assuming knowledge of ASLR. 


:::

::: right
![[0x07_slide_19_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports 

:::

<!-- element style="font-size: 24px"-->
- When a DLL is loaded by a process:
- It is not guaranteed to be placed in the same 
absolute 
location
 in memory 
- Nor is it guaranteed to be placed in the same 
relative
 location 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- To handle variability in load location, the programer can can declare  all imports in the 
Import Address Table 
(IAT)
- This shifts the work to the PE loader to resolve all the imports away from the programmer! 
- When a dependency is declared in the IAT, the PE loader will attempt to resolve the dependency. If it fails, the program crashes. 
- Recall
 this is a 
subtype of dynamic linking 
called 
Implicit Linking


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Resolving Imports
:::

::: left
<!-- element style="font-size: 20px"-->
- The IAT is effectively a collection of key value pairs, where the key is an 
identifier
 of an imported function, and the value is the address of  a small function that jumps to the location of the real function. 
- This is reflected in x64dbg when we set a breakpoint at a call to a remote library: the breakpoint is set at the Virtual Addresses of the remote function, but in our code we reference it via the IAT

:::

::: right
![[0x07_slide_22_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Resolving Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- When resolving imports, the PE loader will load all required DLLs, identify the address of the loaded DLL, and patch the IAT with the correct address of the requested function

:::

::: right
![[0x07_slide_23_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Resolving Imports
:::

<!-- element style="font-size: 24px"-->
- The application code simply calls the function referenced in the IAT, which is itself a 
trampoline 
 to the real code.
- I.e., it is a static location user code can can reference, which is simply an unconditional jump to the real virtual address of the required function.
- WHen a PE lives on disk, this 
jump table
 is null, and is set at runtime by the PE loader.
 
<center>
![[0x07_slide_24_image.png|600]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Visual: IAT
:::

![[0x07_slide_25_image.png|700]]

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Example of a crash: 
:::

::: left
<!-- element style="font-size: 24px"-->
- Double click an EXE with a missing dependency, and you will likely see a message like this:
- - …Hint Hint Nudge Nudge…
- You might need a bit of 
programming
 for 1 of the crackmes!

:::

::: right
![[0x07_slide_26_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Hint
:::

![[0x07_slide_27_image.png|600]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamically Linked Libraries: 

:::

<!-- element style="font-size: 26px"-->
- Refresh: What is a DLL?
- How do we build a DLL?
- How do we execute a DLL? 
- How do we export functions in a DLL?
- How do we call functions from a DLL?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DLL

:::

<!-- element style="font-size: 24px"-->
- A PE with with DLL characteristic field set. 
- Usually it has exported functions which can be referenced by code outside of the DLL

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Building DLLs

:::
<!-- element style="font-size: 24px"-->
- Just like there is boilerplate for `int main()` there is a standard "entrypoint" for DLLs
- It is basically a switchcase and an extra flag set when compiled

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Building DLLs

:::

<br>
<left>

<!-- element style="font-size: 20px"-->
```c

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{

    // Fun fact, doing anything crazy in here 
    // will BREAK EVERYTHING YOU KNOW AND LOVE

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        //OutputDebugStringW(L"DLL_PROCESS_ATTACH");
        break;

    case DLL_THREAD_ATTACH:
        //OutputDebugStringW(L"DLL_THREAD_ATTACH");
        break;

    case DLL_THREAD_DETACH:
        //OutputDebugStringW(L"DLL_THREAD_DETACH");
        break;

    case DLL_PROCESS_DETACH:
        //OutputDebugStringW(L"DLL_PROCESS_DETACH");
        break;
    }

    return TRUE;
}
```
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Exporting Code 

:::

<!-- element style="font-size: 24px"-->
```c
 __declspec(dllexport) int IAmAGoodNoodle()
{   
    MessageBoxA(NULL, "I am a good noodle!", "Very good!", MB_OK );
  return 0;
}


```
- Note for Cpp, you will need an extern “C” directive 

---
<!-- slide template="[[Title Slide]]" -->
 ## Demo
Building a DLL you can link against
---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::
![[0x07_slide_33_image.png|500]]


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DLL Search
:::

::: left
<!-- element style="font-size: 24px"-->
- The PE loader will check multiple well known paths, finally checking the 
current
 directory for the required DLL
- If you aren’t careful with where you set your dependency, you can open up your code to DLL hijacking 


:::

::: right
![[0x07_slide_34_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Running DLLs
:::

::: left
<!-- element style="font-size: 24px"-->
- Rundl32.exe ( there is a 32-bit version and a 64-bit version )
- Rundl32.exe can execute specific functions, or simply the DLLMain
- If you give it the name of an unexported function, it will call ProcessAttach then error out

:::

::: right
![[0x07_slide_35_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Testing our DLL: rundl32 
:::

![[0x07_slide_36_image.png|650]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Testing our DLL: Implicit Linking  
:::

![[0x07_slide_37_image.png|600]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Linking→Explicit Linking 

:::

<!-- element style="font-size: 24px"-->
- The programer explicitly calls LoadLibrary followed by GetProcAddress, and has the proper function prototypes inside of their code. Bot of these functions live in Kernel32.dll
- The legitimate reason to do this, is to allow the execution of the program to continue even if a DLL does not exist.
- If an import for an implicitly loaded DLL is missing, the program stops. 
- The application using  an explicitly loaded DLL can choose how to handle a missing DLL. 
- This is a common in malware trying to hide its imports


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How does this work?

:::

<!-- element style="font-size: 24px"-->
- LoadLibraryA: gets a handle to a library in memory. 
- If the library isn’t already loaded into memory, it will load it! If it can’t, it returns a NULL pointer
	- The handle it returns is the Virtual Address of the memory mapped library for the current 
processes
 Private Address space!
		- In particular, it is the 
base address 
of the library.
- GetProcAddress: given a handle to a library, and an identifier for a function such as a name, it returns the Virtual Address of the funcion!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Using Function Pointers

:::

<!-- element style="font-size: 24px"-->
- Functions aren’t first class objects in C/C++
- However, functions themselves are just memory addresses!
	-  with arguments that give the compiler hints on how to call it!
- To invoke a function by a memory address, we first need the address of the function, and information about how to call it
- We can either handle this using raw assembly, or we can declare a 
function
 pointer type with the arguments and calling conventions specified
- Then we just cast the raw address to a function pointer type and call it!


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: 
Explicitly Linked Mbox
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reverse Engineering Implications

:::

<!-- element style="font-size: 24px"-->
- If a dll is explicitly linked, you cannot set a breakpoint for the library in the entry point (why?)
- The DLL doesn’t show up in the IAT 
- How can we hide the strings for LoadLibrary/GetProcAddress?


---
<!-- slide template="[[Title Slide]]" -->
 ## Crackmes: Fall 2021
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 0
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended difficulty: trivial (so long as you know how to find the main entry point!)
- Run strings on the binary. 
- Find main
- See that it is directly comparing your input to a static string

:::

::: right
![[0x07_slide_4_image.png|400]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 1:
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Easy
- The binary checks if the length of the input is 26, and if it starts with a C

:::

::: right
![[0x07_slide_5_image.png|300]]



:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (Learn from my mistakes. )
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Moderate
- Question to answer: WTF is happening inside of that do-while loop?

:::

::: right
![[0x07_slide_6_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Crackme 2 (Again, learn from my mistakes!)

:::

<!-- element style="font-size: 24px"-->
- A stack variable is declared, with values inside of the ASCII range (HINT)
- We iterate through values in argv[1]
- Copy that character into a buffer
- Copy the char from the stack var into a buffer
- Checks to see if the the input char + 5 is the same as the stack variable
- If not, Fail. If yes, continue
- Once we are done checking all the characters in the stack string with no errors, Success 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (...Oops)
:::

::: left
<!-- element style="font-size: 22px"-->
- Moral of the story: Don’t leave your work until the night before it is due.
- You 
will
 make careless mistakes, and if you’re like me and don’t have tenure it could be a bad look!
- Also…maybe don’t use 
aggressive
 Debug statements. 
- OR git commit messages:
https://www.youtube.com/watch?v=KjYBh7rq0-


:::

::: right
![[0x07_slide_8_image.png|400]]


:::

